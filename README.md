# java-ladder

# Log
- 2023 / 03 / 19 : 기본적인 구현 완료 (추가적인 Test 필요)
---
# 1주차 미션 - 사다리 타기 요구사항 1단계
# 기능 요구사항 1: 사다리 타기 구현

---

## **사다리 타기 게임을 구현한다.**

핵심은 **몇 번째 사다리를 탈지 입력하면, 몇 번째 사다리가 나오는지 반환**하는 것이다.

1. `Ladder` 클래스에 생성자 인자로
   **사다리 줄의 개수(게임에 참여하는 사람의 수)**와 **사다리의 높이**를 전달하면 사다리를 생성하도록 한다.
    - 사다리의 각 라인의 생성은 `drawLine(postion)` 메서드를 만들어 수동으로 사다리를 만들 수 있게 한다. 즉, 처음 만들어진 사다리는 아예 빈 사다리이다.
    - 이후 drawLine 메서드를 통해 사다리의 라인을 만들어 나갈 수 있도록 한다.

1. Ladder 클래스의 `run` 메서드를 통해
   몇 번째 사다리를 선택하면 도착하는 사다리의 번호를 알 수 있도록 구현한다.
    - 인자로 몇 번째 사다리를 선택할지 전달해야 한다.
        - 예시 : `1`을 인자로 전달 → `ladder.run(1)` →  `1`을 반환
    - 우선 `drawLine()`으로 사다리를 만들고, 해당 사다리가 잘 작동하는지 테스트한다.

1. 메서드에게 하나의 일만 시키도록 한다.
    - 아래의 객체지향 생활체조의 원칙대로 들여쓰기와 함수의 길이를 제한하여 메서드를 분리한다.

1. 테스트 코드로 단위 테스트를 하도록 한다.
    - 기존 main 메서드의 표준 입출력으로 테스트 하던 것을 모두 Junit 테스트 코드로 대체한다.
    - 1번 요구사항으로 구현한 Ladder 클래스가 정상적으로 동작하는지 확인하기 위해 테스트 코드를 작성한다.
    - Ladder 클래스의 run 메서드가 여러 상황에도 알맞은 값을 반환하는지를 테스트를 통해 확인한다.

1. 아래의 객체지향 생활 체조원칙을 최대한 지키면서 구현하도록 한다.
    - 처음부터 완벽한 객체지향적인 코드를 짜는 것은 매우 어려운 일이다.
    - 우선 객체지향보다 구현에 집중한다.
    - 이후 리팩터링하며 아래 원칙을 적용해보도록 하자!

# 객체지향 생활 체조 원칙 9단계 (소트웍스 엔솔로지)

---

이 원칙들을 전부 지키면서 개발하는 것은 어려운 것이 사실이다.

하지만 이들을 의식적으로 제한하여 자신의 한계를 뛰어넘어보자!

### 1️⃣ 한 메서드에 한 단계의 들여쓰기만 허락한다

- 이중 반복문, 반복문 안에 조건문 등은 두 단계의 들여쓰기이다.
- 들여쓰기를 줄이는 가장 좋은 방법은 `메서드의 분리`이다.

### 2️⃣ else를 쓰지 않는다

- 조건문은 복제의 원인이 되고, 가독성이 좋지 않다.
- if 문 안에서 return을 한면 else 문을 사용하지 않을 수 있다. (`early return`)

### 3️⃣ 모든 원시값과 문자열을 객체로 포장(wrap)한다

- primitive type(원시값)으로는 컴파일러가 의미적으로 맞는 프로그램 작성을 안내할 수 없다.
    - e.g., 돈은 음수가 될 수 없는데 0 이상의 정수값만 포함하는 원시값이 있는가?
- 포장한 객체를 통해서라면 이 객체를 통해 예외를 처리할 수 있으며,
  컴파일러와 개발자에게 어떤 값이며 왜 사용하는지를 전달할 수 있다.

### 4️⃣ 한 줄에 점을 하나만 찍는다

- 어느 코드 한 곳에서 점이 둘 이상 있다면, 해당 부분을 다시 리팩터링해야 한다.
- `디미터 법칙` : ‘친구하고만 대화하라’
    - 자신이 소유한 객체, 자신이 생성한 객체, 그리고 파라미터로 받은 객체에만 메시지를 보내야 한다.
    - `객체.객체.객체.get()`처럼 연속으로 여러 객체가 참조된다면 캡슐화를 어기게 된다.
    - 메시지를 받는 객체는 자신을 보여주는 것보다는
      받은 메시지에 대해 작업을 하고 작업 결과를 전달하도록 하자.

### 5️⃣ 줄여쓰지 않는다

- 과도한 축약은 가독성을 저해한다.

### 6️⃣ 모든 entity를 작게 유지한다

- 50 줄 이상 되는 클래스 또는 10개 파일 이상의 패키지는 없어야 한다.
- 50 줄이 넘어가면 스크롤을 해야 하고, 한 가지 일만 하지 않고 있을 가능성이 크다.

### 7️⃣ 2개 이상의 인스턴스 변수를 가진 클래스를 쓰지 않는다

- 여기서 인스턴스 변수는 기본형 또는 자료구조형 변수를 말하며,
  일급 컬렉션이나 Wrapper 객체는 해당하지 않는다.
- 새로운 인스턴스 변수를 가진 클래스는 응집도가 떨어진다.
- 많은 인스턴스 변수를 가진 클래스로 응집력 있는 단일 작업을 설명할 수 있는 경우는 거의 없다.
- 인스턴스 변수들의 집합을 갖고 있는 것에서
  **협력 객체(일급 컬렉션, Wrapper 객체)의 계층 구조로 분해하면** 더욱 효율적인 모델이 될 수 있다.

### 8️⃣ 일급 컬렉션을 쓴다

- 컬렉션을 포함한 클래스는 반드시 다른 멤버 변수가 없어야 한다.
- 일급 컬렉션은 원시값을 클래스로 포장한 것처럼, **컬렉션을 클래스로 포장한 것을 의미한다.**

예를 들어, 로또를 구현한다고 해보자.

- 로또 하나가 6개의 숫자만을 가지고 있어야 한다는 제약이 존재한다.
- 보통은 Lotto 클래스를 만들어서 `List<Integer> lottos`라는 필드를 가지는 것으로 구현할 것이다.
- 이 lottos를 일급 컬렉션으로 관리한다면, 즉 다른 클래스로 lottos를 포장하여 Lotto 클래스의 지역변수로 저장한다면 ‘6개의 숫자만을 가지고 있어야 한다’는 제약을 해당 클래스 내에서 관리할 수 있게 된다.

✅ **일급 컬렉션의 장점**

- **비즈니스에 종속적인 자료구조** : 바로 위에서 언급했듯, 비즈니스 제약을 wrap한 클래스에서 둘 수 있다.
- **불변 보장**
    - 원래 컬렉션은 `set` , `add`  메서드로 값을 변화시킬 수 있다.
    - 컬렉션을 클래스로 포장하여 캡슐화하면 위와 같은 변화를 막을 수 있다.
- **상태와 행위를 한 곳에서 관리**
    - 컬렉션에는 상태가 들어있다.
      원래라면 이러한 상태에 대한 계산은 컬렉션에서 빼와서 외부에서 진행해야 한다.
    - 그러나 클래스를 클래스로 포장하게 된다면 상태에 대한 계산을 클래스가 전담할 수 있다.
- **컬렉션에 이름을 붙일 수 있다.**

### 9️⃣ getter / setter / property를 쓰지 않는다

- getter를 통해 값을 가져와 변수를 컨트롤한다면 캡슐화의 의미가 사라진다.
- **객체가 자신의 상태(변수)에 대해서 스스로 작업하고 메시지를 전달하도록 하자.**
